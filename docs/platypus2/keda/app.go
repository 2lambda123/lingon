// Copyright (c) 2023 Volvo Car Corporation
// SPDX-License-Identifier: Apache-2.0

// Code generated by lingon. EDIT AS MUCH AS YOU LIKE.

package keda

import (
	"context"
	"errors"
	"os"
	"os/exec"

	"github.com/volvo-cars/lingon/pkg/kube"
	"github.com/volvo-cars/lingoneks/meta"
	appsv1 "k8s.io/api/apps/v1"
	corev1 "k8s.io/api/core/v1"
	rbacv1 "k8s.io/api/rbac/v1"
	apiregistrationv1 "k8s.io/kube-aggregator/pkg/apis/apiregistration/v1"
)

var KD = Core()

func Core() *Meta {
	ver := "2.11.1"

	return &Meta{
		Metadata: meta.Metadata{
			Name:      "keda-operator",
			Namespace: "keda",
			Instance:  "keda",
			Component: "operator",
			PartOf:    "keda-operator",
			Version:   ver,
			ManagedBy: "lingon",
			Img: meta.ContainerImg{
				Registry: "ghcr.io/kedacore",
				Image:    "keda",
				Tag:      ver,
			},
		},
		ProbePort: 8081,
		P: meta.NetPort{
			Container: corev1.ContainerPort{
				Name:          "http",
				ContainerPort: 8080,
			},
			Service: corev1.ServicePort{},
		},
		MetricsAPI: meta.Metadata{
			Name:      "keta-operator-metrics-apiserver",
			Namespace: "keda",
			Instance:  "keda",
			Component: "operator",
			PartOf:    "keda-operator",
			Version:   ver,
			ManagedBy: "lingon",
			Img: meta.ContainerImg{
				Registry: "ghcr.io/kedacore",
				Image:    "keda-metrics-apiserver",
				Tag:      "2.11.1",
			},
		},
		MetricsAPIPort: meta.NetPort{
			Container: corev1.ContainerPort{
				Name:          "",
				HostPort:      0,
				ContainerPort: 0,
				Protocol:      "",
				HostIP:        "",
			},
			Service: corev1.ServicePort{},
		},
		MetricsAPIMetricsPort: meta.NetPort{
			Container: corev1.ContainerPort{},
			Service:   corev1.ServicePort{},
		},
	}
}

type Meta struct {
	meta.Metadata
	P         meta.NetPort
	ProbePort int32

	MetricsAPI            meta.Metadata
	MetricsAPIPort        meta.NetPort
	MetricsAPIMetricsPort meta.NetPort
}

// validate the struct implements the interface
var _ kube.Exporter = (*Keda)(nil)

// Keda contains kubernetes manifests
type Keda struct {
	kube.App

	NS *corev1.Namespace

	OperatorAuthReaderRB                    *rbacv1.RoleBinding
	OperatorCR                              *rbacv1.ClusterRole
	OperatorCRB                             *rbacv1.ClusterRoleBinding
	OperatorDeploy                          *appsv1.Deployment
	OperatorExternalMetricsReaderCR         *rbacv1.ClusterRole
	OperatorHpaControllerExternalMetricsCRB *rbacv1.ClusterRoleBinding
	OperatorMetricsApiserverDeploy          *appsv1.Deployment
	OperatorMetricsApiserverSVC             *corev1.Service
	OperatorRB                              *rbacv1.RoleBinding
	OperatorRole                            *rbacv1.Role
	OperatorSA                              *corev1.ServiceAccount
	OperatorSVC                             *corev1.Service
	OperatorSystemAuthDelegatorCRB          *rbacv1.ClusterRoleBinding
	V1Beta1ExternalMetricsK8SIoApiservices  *apiregistrationv1.APIService
}

// New creates a new Keda
func New() *Keda {
	return &Keda{
		OperatorAuthReaderRB:                    OperatorAuthReaderRB,
		OperatorCR:                              OperatorCR,
		OperatorCRB:                             OperatorCRB,
		OperatorDeploy:                          OperatorDeploy,
		OperatorExternalMetricsReaderCR:         OperatorExternalMetricsReaderCR,
		OperatorHpaControllerExternalMetricsCRB: OperatorHpaControllerExternalMetricsCRB,
		OperatorMetricsApiserverDeploy:          OperatorMetricsApiserverDeploy,
		OperatorMetricsApiserverSVC:             OperatorMetricsApiserverSVC,
		OperatorRB:                              OperatorRB,
		OperatorRole:                            OperatorRole,
		OperatorSA:                              OperatorSA,
		OperatorSVC:                             OperatorSVC,
		OperatorSystemAuthDelegatorCRB:          OperatorSystemAuthDelegatorCRB,

		V1Beta1ExternalMetricsK8SIoApiservices: V1Beta1ExternalMetricsK8SIoApiservices,
	}
}

// Apply applies the kubernetes objects to the cluster
func (a *Keda) Apply(ctx context.Context) error {
	return Apply(ctx, a)
}

// Export exports the kubernetes objects to YAML files in the given directory
func (a *Keda) Export(dir string) error {
	return kube.Export(a, kube.WithExportOutputDirectory(dir))
}

// Apply applies the kubernetes objects contained in Exporter to the cluster
func Apply(ctx context.Context, km kube.Exporter) error {
	cmd := exec.CommandContext(ctx, "kubectl", "apply", "-f", "-")
	cmd.Env = os.Environ()        // inherit environment in case we need to use kubectl from a container
	stdin, err := cmd.StdinPipe() // pipe to pass data to kubectl
	if err != nil {
		return err
	}

	cmd.Stdout = os.Stdout
	cmd.Stderr = os.Stderr

	go func() {
		defer func() {
			err = errors.Join(err, stdin.Close())
		}()
		if errEW := kube.Export(
			km,
			kube.WithExportWriter(stdin),
			kube.WithExportAsSingleFile("stdin"),
		); errEW != nil {
			err = errors.Join(err, errEW)
		}
	}()

	if errS := cmd.Start(); errS != nil {
		return errors.Join(err, errS)
	}

	// waits for the command to exit and waits for any copying
	// to stdin or copying from stdout or stderr to complete
	return errors.Join(err, cmd.Wait())
}

// P converts T to *T, useful for basic types
func P[T any](t T) *T {
	return &t
}
